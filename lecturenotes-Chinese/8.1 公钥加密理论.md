# 8.1 公钥加密理论

1. 本节学习用于保护信息的完整性和真实性的消息认证码（MAC）和抗碰撞的哈希函数（CRHF）。

2. 目录：公钥加密的定义和安全，陷门排列，选择密文攻击安全，在随机预言机模型中从陷门排列到公钥加密。

3. 私钥密码学局限性

   - 密钥分发需要通信各方在物理上会面；
   - $U$个用户的密钥的数量 $\Theta(U^2)$；
   - 开放系统的安全通信：基于私钥密码学的解决方案无法充分处理开放系统中的安全通信问题，在开放系统中通信各方不能物理上会面，或只能暂时交互；
   - 注：私钥密码学中的一个核心问题就是密钥分发与管理问题。

4. **Needham-Schroeder 协议**

   - *Needham–Schroeder Symmetric Key Protocol*：在开放网络中双方通过一个可信的第三方建立一个会话密钥（session key）；
   - 密钥分发中心（Key Distribution Center，KDC）作为可信的第三方（Trusted Third Party，TTP），与通信双方Alice和Bob在事前分别建立了对称密钥；
   - KDC根据Alice的请求，生成一个新的 $k$ 会话密钥（session key），分别用与Alice和Bob分别共享的密钥来加密并发送给Alice；$E_{Bob}(k)$ 作为一个来访问Bob所需的凭证（ticket）；
   - 用于MIT's Kerberos 协议 (in Windows)；
   - 优点：每一方只需要存储一个密钥；不需要更新通信双方密钥（因为采用新的会话密钥）；
   - 弱点：单点失效，一旦KDC被破坏，则整个系统都不安全。

5. Merkle难题（无需可信第三方的密钥交换）

   - Alice准备 $2^{32}$ 个难题 $\mathsf{Puzzle}_i$，并且发送给Bob；难题如下：

     $\mathsf{Puzzle}_i \gets \mathsf{Enc}_{(0^{96}\|p_i)}(\text{``Puzzle \#''} x_i \| k_i),$，其中 $\mathsf{Enc}$ 是 128位加密，$p_i \gets \{0,1\}^{32}$ 并且 $x_i,k_i \gets \{0,1\}^{128}$。

     注：每个难题中明文包括一个随机数和一个密钥，用一个密钥加密；

   - Bob随机选择一个难题 $\mathsf{Puzzle}_j$，并且在 $2^{32}$ 时间内猜测  $p_j$ ，获得 $x_j,k_j$ 并将 $x_j$ 发送给 Alice。

   - Alice 按照$x_j$查询谜题，并且使用 $k_j$ 作为密钥。

   - 敌手需要 $2^{32+32}$ 时间，是诚实放所需时间复杂性的二次方。

   - 在诚实方和敌手之间存在更好的差距吗？如果将加密方法看作是一个黑盒预言机，那么二次差距是最好的。

   - Merkle难题的缺点是谜题数量太大，获得密钥的代价太大；

6. 公钥革命

   - 在1976年，Whitfield Diffie 和 Martin Hellman 发表了 “New Directions in Cryptography” （密码学的新方向）。
   - 非对称（Asymmetric）或公钥（public-key）加密方案:
     - 公钥（Public key）作为加密密钥；（注：接收方产生，发送方持有）
     - 私钥（Private key）作为解密密钥； （注：接收方产生，接收方持有）
   - 公钥原语（Public-key primitives）:
     - 公钥加密（Public-key encryption）
     - 数字签名（Digital signatures） (不可抵赖性，non-repudiation)
     - 交互式密钥交换（Interactive key exchange）
   - 优点：
     - 在公开信道上密钥分发
     - 减少保存大量密钥的需求
     - 使得在开放系统的安全成为可能
   - 缺点：慢，针对公钥分发的主动攻击（注：如何保证Alice得到的公钥真的是Bob的公钥？）

7. 公钥加密定义

   - 密钥生成（Key-generation）算法: $(pk,sk) \gets \mathsf{Gen}$, 密钥长度 $\ge n$；
   - 明文空间： $\mathcal{M}$ 与 $pk$ 相关；（注：公钥加密方案通常以数学难题为基础，明文与公钥之间并不完全独立）
   - 加密（Encryption）算法: $c \gets \mathsf{Enc}_{pk}(m)$.
   - 解密（Decryption）算法：$m:= \mathsf{Dec}_{sk}(c)$, 或者输出 $\perp$.
   - 需求：$\Pr[\mathsf{Dec}_{sk}(\mathsf{Enc}_{pk}(m)) = m] \ge 1 - \mathsf{negl}(n)$. （注：公钥加密方案通常以数学难题为基础，存在解密不成功的可能。）

8. 对窃听者的安全 = CPA

   - 窃听不可区分实验 $\mathsf{PubK}^{\mathsf{eav}}_{\mathcal{A},\Pi}(n)$:
     -  $(pk,sk) \gets \mathsf{Gen}(1^n)$.
     -  $\mathcal{A}$ \textbf{is given input $\mathbf{pk}$ and so oracle access to $\mathbf{\mathsf{Enc}_{pk}(\cdot)}$}, outputs $m_0, m_1$ of the same length. 
     -  $b \gets \{0,1\}$. $c \gets \mathsf{Enc}_{pk}(m_b)$ (challenge) is given to $\mathcal{A}$.
     -  $\mathcal{A}$ \textbf{continues to have access to $\mathbf{\mathsf{Enc}_{pk}(\cdot)}$} and outputs $b'$.
     -  If $b' = b$, $\mathcal{A}$ succeeded $\mathsf{PrivK}^{\mathsf{eav}}_{\mathcal{A},\Pi}=1$, otherwise 0.
   - 定义：$\Pi$ is \textbf{CPA-secure} if $\forall$ \textsc{ppt} $\mathcal{A}$, $\exists$ $\mathsf{negl}$ such that

   $ \Pr\left[\mathsf{PubK}^{\mathsf{cpa}}_{\mathcal{A},\Pi}(n)=1\right] \le \frac{1}{2} + \mathsf{negl}(n). $

9. 公钥加密的安全属性

10. 混合加密（**Hybrid Encryption**）构造

11. 混合加密安全

12. 陷门排列（**Trapdoor Function**）

13. 陷门排列族

14. TDP例题

15. 从TDP到公钥加密方案

16. 证明

17. 证明（续）

18. 在公钥设定中CCA情景

19. 对CCA/CCA2的安全定义

20. 例题

21. CCA2安全加密技术进展

22. 随机预言机模型（**Random Oracle Model，ROM**）

23. ROM的简单例子

24. CPA安全

25. 基于私钥加密的CCA安全

26. 在ROM中基于TPD的CCA安全

27. 私钥加密 vs. 公钥加密



