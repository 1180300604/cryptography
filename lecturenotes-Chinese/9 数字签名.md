# 9 数字签名

1. 本节学习公钥密码学中用于保护信息完整性和真实性的数字签名。

2. 目录：数字签名定义、RSA签名、来自离散对数问题的数字签名、一次签名方案、证书与公钥基础设施。

3. 数字签名概览
   
   - 数字签名（Digital signature）是一个数学方案用来证明一个数字消息的真实性/完整性。
   - 数字签名允许一个签名者（Signer）$S$ 用其自己的私钥来“签名”（sign）一个消息，并且任何知道 $S$ 的公钥的人可以验证（verify）其真实性/完整性。
   - 与MAC相比，数字签名是：
     - 公开可验证的（publicily verifiable）；
     - 可转移的（transferable）；
     - 不可抵赖（non-repudiation）；
     - 但速度慢。
   - 问题：数字签名和手写签名的却别是什么？
   - 数字签名**不是**公钥加密的逆。
   
4. 数字签名方案词法

   - 签名 $\sigma$, 比特 $b$ 表示有效（ $\mathsf{valid}$）如果 $b=1$; 无效（$\mathsf{invalid}$）如果 $b=0$。
   - 密钥生成算法（Key-generation）：$(pk,sk) \gets \mathsf{Gen}(1^n), |pk|,|sk| \ge n$。
   - 签名（Signing）算法：$\sigma \gets \mathsf{Sign}_{sk}(m)$。
   - 验证（Verification）算法：$b:= \mathsf{Vrfy}_{pk}(m,\sigma)$。
   - 基本正确性要求： $\mathsf{Vrfy}_{pk}(m,\mathsf{Sign}_{sk}(m)) = 1$。

5. 定义签名安全

   - 安全数字签名定义与安全MAC类似，敌手难以伪造一个“新消息”的签名。
   - 签名实验 $\mathsf{Sigforge}_{\mathcal{A},\Pi }(n)$:
     1. 挑战者生成密钥对 $(pk,sk) \gets \mathsf{Gen}(1^n)$。
     2. 敌手 $\mathcal{A}$ 给予输入 $1^n$ 以及对签名预言机的访问 $\mathsf{Sign}_{sk}(\cdot)$，然后输出 $(m,\sigma)$。 $\mathcal{Q}$ 是对预言机的查询的集合。
     3. 实验成功 $\mathsf{Sigforge}_{\mathcal{A},\Pi }(n)=1 \iff$ $\mathsf{Vrfy}_{pk}(m,\sigma)=1$ $\land$ $m \notin \mathcal{Q}$. 
   - 一个签名方案 $\Pi$ 是在适应性选择消息攻击下的存在性不可伪造（existentially unforgeable under an adaptive CMA），如果 $\forall$ PPT $\mathcal{A}$, $\exists$ $\mathsf{negl}$ 使得:  $ \Pr [\mathsf{Sigforge}_{\mathcal{A},\Pi }(n)=1] \le \mathsf{negl}(n).$
   - 问题：在MAC和数字签名中敌手能力的差别是什么？如果敌手不限制算力为PPT会如何？

6. “书本上RSA”的不安全性

   - 构造：
     - $\mathsf{Gen}$: on input $1^n$ run $\mathsf{GenRSA}(1^n)$ to obtain $N,e,d$. $pk = \langle N,e \rangle$ and $sk = \langle N,d \rangle$.
     -  $\mathsf{Sign}$: on input $sk$ and $m \in \mathbb{Z}^*_N$, $\sigma:= [m^d \bmod N]$.
     -  $\mathsf{Vrfy}$: on input $pk$ and $m \in \mathbb{Z}^*_N$, $m \overset{?}{=} [\sigma^e \bmod N]$.
   - 无消息攻击（no-message attack）：
     - 选择一个任意 $\sigma \in \mathbb{Z}^*_N$ 并且计算 $m := [\sigma^e \bmod N]$。输出伪造签名 $(m,\sigma)$。
     - 例子：$pk = \left<15, 3\right>,\ \sigma = 2,\ m = ?\ m^{d} = ?$
   - 伪造任意消息的签名（Forging a signature on an arbitrary message）：为了伪造 $m$ 的签名，选择一个随机的 $m_1$，令 $m_2 := [m/m_1 \bmod N]$，查询预言机获得消息  $m_1, m_2$ 的签名 $\sigma_1, \sigma_2$ 。
     - 问题：$\sigma := [\underline{\qquad} \bmod N]$ 是 $m$ 的一个有效签名。

7. 哈希（Hashed）RSA

   - 目前实际使用哈希RSA数字签名方案：
     - $\mathsf{Gen}$: 一个哈希函数 $H : \{0,1\}^* \to \mathbb{Z}_N^*$ 作为公钥的一部分。
     - $\mathsf{Sign}$: $\sigma := [H(m)^d \bmod N]$.
     - $\mathsf{Vrfy}$: $\sigma^e \overset{?}{=} H(m) \bmod N$.
   - 如果 $H$ 无法有效求逆，那么无消息攻击和伪造任意消息的签名都是难的。
   - 不安全性：没有已知函数 $H$ 使得哈希RSA签名是安全的。
   - RSA-FDH 签名方案：随机预言机作为一个全域哈希（Full Domain Hash，FDH)），其定义域大小为 RSA 的模数 $N-1$。（PKCS \#1 v2.1）

8. “哈希签名”范式

   - 将消息哈希后再签名可以实现安全的数字签名。
   - $\Pi = (\mathsf{Gen}_S, \mathsf{Sign}, \mathsf{Vrfy})$, $\Pi_H = (\mathsf{Gen}_H, H)$. 一个签名方案 $\Pi'$:
     - $\mathsf{Gen}'$: 输入 $1^n$ 运行 $\mathsf{Gen}_S(1^n)$ 来得到 $(pk,sk)$, 并且运行 $\mathsf{Gen}_H(1^n)$ 来得到 $s$。 公钥是 $pk'=\langle pk,s\rangle$ 并且私钥是 $sk' = \langle sk,s\rangle$。
     - $\mathsf{Sign}'$: 输入 $sk'$ 并且 $m \in \{0,1\}^*$, $\sigma \gets \mathsf{Sign}_{sk}(H^s(m))$。
     - $\mathsf{Vrfy}'$: 输入 $pk'$, $m \in \{0,1\}^*$ 并且 $\sigma$, 输出 1 $\iff$ $\mathsf{Vrfy}_{pk}(H^s(m),\sigma)=1$。
   - 定理：如果 $\Pi$ 是在适应性CMA下的存在性不可伪造，并且 $\Pi_H$ 是抗碰撞，那么构造是适应性CMA下的存在性不可伪造。
   - 证明：敌手无法实施之前的“无消息攻击”和“伪造任意消息签名攻击”。敌手的成功需要发现哈希碰撞，或者针对$\Pi$伪造签名。

9. 身份认证方案

   - 下面学习**Schnorr**身份认证方案，该方案可以用于构造基于离散对数问题的**Schnorr**数字签名方案。
   - 一个身份认证（identification）方案 $\Pi = (\mathsf{Gen}, \mathcal{P}_1, \mathcal{P}_2, \mathcal{V})$ 是一个在证明者（prover）和验证者（verifier）之间的三轮协议。其中，证明者运行$\mathcal{P}_1, \mathcal{P}_2$两个算法，验证者运行$\mathcal{V}$算法。
   - 证明者说服验证者其是一个公钥所对应的私钥的持有者，通过“知道什么”来证明自己的身份。
   - 敌手能够窃听并且可以通过作为一个验证者来访问一个预言机 $\mathsf{Trans}_{sk}$ 来获得信息 $(I, r, s)$ 。
   - 身份认证协议：
     1. 证明者生成$(I, \mathsf{st})\gets \mathcal{P}_1(sk)$，并将$I$发送给验证者。*注：这里不能泄漏关于私钥的信息，并且这个$I$可用于保护私钥。*
     2. 验证者生成 $r \gets \Omega_{pk}$，并将$r$发送给证明者。*注：挑战信息不能被证明者预知，否则证明者有可能在不知道私钥的情况下伪装自己*
     3. 证明者生成 $s := \mathcal{P}_2(sk, \mathsf{st}, r)$，并将$s$发送给证明者。*注：证明者对挑战作出响应，必然要用到自己的私钥，但不能让验证者推断出私钥*
     4. 验证者验证$\mathcal{V}(pk, r, s) \overset{?}{=} I$。*注：确定只有私钥的持有者能通过验证*
   - 其中，$\mathsf{st}$ 表示证明者维护的状态信息。

10. 身份认证方案安全定义

    - 思路：敌手能够作为验证者进行实验，但仍不能自己伪装成证明者。

    - 身份认证实验 $\mathsf{Ident}_{\mathcal{A},\Pi }(n)$:

      1.  证明者生成密钥对，$(pk,sk) \gets \mathsf{Gen}(1^n)$.
      2. 敌手 $\mathcal{A}$ 给予输入 $1^n$ 和对 $\mathsf{Trans}_{sk}(\cdot)$ 的预言机访问，输出一个消息 $I$。
      3. 挑战者挑选一个均匀的挑战 $r$ 并将其发送给 $\mathcal{A}$，然后敌手 $\mathcal{A}$ 输出 $s$。 ($\mathcal{A}$ 可以继续查询预言机。)
      4. 实验成功如果验证成功，$\mathsf{Ident}_{\mathcal{A},\Pi }(n) = 1 \iff \mathcal{V}(pk, r, s) \overset{?}{=} I$。 

    - 定义：一个身份认证方案 $\Pi = (\mathsf{Gen}, \mathcal{P}_1, \mathcal{P}_2, \mathcal{V})$ 是安全的，如果 $\forall$ PPT $\mathcal{A}$, $\exists$ $\mathsf{negl}$ 使得:

      $ \Pr [\mathsf{Ident}_{\mathcal{A},\Pi }(n) = 1] \le \mathsf{negl}(n). $

11. Schnorr身份认证方案

    - Schnorr身份认证方案：
      1. 证明者持有一个离散对数问题$g^x = y$的私钥部分$x$，生成$k \gets \mathbb{Z}_q$; $I := g^k$，并将$I$发送给验证者。*注：这个$k$就是 $\mathsf{st}$, 后面用来隐藏私钥$x$*
      2. 验证者生成 $r \gets \mathbb{Z}_q$，并将$r$发送给证明者。*注：随机的$r$不能被预测*
      3. 证明者生成 $s := [rx + k \mod q]$，并将$s$发送给证明者。*注：用$x$生成应答，并用$k$隐藏$x$*
      4. 验证者验证$\mathcal{V}(pk, r, s) = g^s \cdot y^{-r} \overset{?}{=} I$。*注：$g^s \cdot y^{-r} = g^{rx+k} g^{-rx} = g^k$  *
    - 定理：如果离散对数是难的，那么Schnorr身份认证方案是安全的。

12. Schnorr身份认证方案证明

    - 思路：如果攻击身份认证方案的敌手可以成功使得 $g^s \cdot y^{-r} = I$，那么离散对数问题可以被解决。
    - 证明：将求$y$的逆的算法 $\mathcal{A}'$ 规约到攻击Schnorr方案的$\mathcal{A}$:
      -  $\mathcal{A}'$ 作为验证者并运行 $\mathcal{A}$ 作为证明者，$\mathcal{A}'$回答$\mathcal{A}$的查询。
      - 当 $\mathcal{A}$ 输出 $I$, $\mathcal{A}'$ 选择 $r_1 \in \mathbb{Z}_q$ 并且发送给 $\mathcal{A}$，后者以 $s_1$ 应答。
      - 再一次运行 $\mathcal{A}$ ，将 $r_2 \in \mathbb{Z}_q$ 发送给 $\mathcal{A}$ ，后者其应答 $s_2$。
      - 如果 $g^{s_1} \cdot h^{-r_1} = I$ 并且 $g^{s_2} \cdot h^{-r_2} = I$ 并且 $r_1 \neq r_2$ 那么输出 $x = [ (s_1 - s_2)\cdot (r_1 - r_2)^{-1} \mod q]$，否则输出空。

13. Fiat-Shamir变换

14. Schnorr签名方案

15. DSS/DSA（数字签名标准/算法）

16. DSS/DSA正确性与安全性

17. 一次签名（OTS）

18. Lamport的OTS

19. Lamport的OTS例子

20. Lamport的OTS安全性证明

21. 有状态签名方案

22. 链式签名

23. 树式签名

24. 无状态解决方案

25. 证书

26. 公钥基础设施（PKI）

27. 无效化证书

28. 总结

    - 略。





